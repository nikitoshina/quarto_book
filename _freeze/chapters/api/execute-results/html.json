{
  "hash": "9142a29a40f41ee3d42328563237a176",
  "result": {
    "markdown": "---\ntitle: \"APIs\"\n---\n\n\nAPIs are invaluable! They provide a streamlined method of interacting with other servers to obtain data. Imagine needing to manually collect songs from Spotify or web scrape weather data instead of simply making an API request. So, what exactly is an API?\n\nConsider it this way: when you enter a restaurant, you take a seat and order food from the menu. You don't march into the kitchen to instruct the chef - that would be chaotic and inefficient. Instead, your order is delivered by a waiter.\n\nIn this analogy, you're the client, the kitchen is the server, your order is the request, the food prepared is the response, and the waiter is the API.\n\nMuch like a waiter knows the protocols of taking your order, conveying it to the kitchen, and serving you, an API dictates how to make requests, which are valid, the delivery method of responses, and their format.\n\nThe waiter shields you from the kitchen's complexity and heat, similar to how an API safeguards you from the server-side operations' intricacies. You're not required to understand the chef's cooking process; all you need to do is relay your order to the waiter and wait for your meal. Likewise, using an API doesn't necessitate an understanding of the server-side procedures, just make the request correctly and handle the response received.\n\nIn essence, APIs, akin to restaurant waiters, facilitate communication and interaction between different system components, ensuring smooth operations.\n\n## Monsieur!\n\nCommunicating with an API involves sending a request with the required data. There are several types of requests you can make:\n\n1. **GET Request**: This is akin to asking a waiter for a meal. It involves requesting data without making changes. In the context of APIs, a GET request fetches information from the server.\n\n2. **POST Request**: This is analogous to ordering a new dish to be added to a menu. It entails giving the API precise instructions to ask the server to add a new item. In API terminology, a POST request transmits data to the server, generating a new entry.\n\n3. **PUT or PATCH Request**: Suppose you want to adjust your order, say, add extra cheese to your burger. This action corresponds to a PUT or PATCH request in the API domain, used to update existing information. While PUT updates the entire record, PATCH only updates the specific parts indicated.\n\n4. **DELETE Request**: Imagine canceling and removing an item from your order after receiving your meal. This action aligns with a DELETE request, which deletes existing data from the server.\n\nThese basic types of HTTP requests are akin to your interaction with a waiter at a restaurant. Just as clear communication with the waiter is necessary for a correct order, using the appropriate request type is crucial when dealing with APIs to obtain the required data or perform the desired operation.\n\n## Your First Order\n\nFundamentally, an API request is similar to your browser downloading a webpage when you open a link. For instance, you can fetch data from the US Census ACS 2021 by following this link: <https://api.census.gov/data/2021/acs/acs5?get=NAME,group(B01001)&for=us:1>\n\nUsually, an interface is needed to interact with an API, rather than constructing a text link. There's a plethora of them, but I'm partial to [HTTPie](https://httpie.io/cli), a CLI tool that also provides online and local applications!\n\nTo install it, simply run `brew install httpie` in a terminal if you have Homebrew or follow the [instructions on their website](https://httpie.io/cli), where you can also access their applications.\n\nWhether you use `http` in your terminal or go to their website, you can easily make your first API request.\n\n`https httpie.io/hello`\n\nThis command will return a header with information and a return message formatted as a JSON string:\n\n\n::: {.cell}\n\n```{.json .cell-code}\n{\n    \"ahoy\"` [\n        \"Hello, World! üëã Thank you for trying out HTTPie ü•≥\",\n        \"We hope this will become a friendship.\"\n    ],\n    \"links\"` {\n        \"discord\"` \"https://httpie.io/discord\",\n        \"github\"` \"https://github.com/httpie\",\n        \"homepage\"` \"https://httpie.io\",\n        \"twitter\"` \"https://twitter.com/httpie\"\n    }\n}\n```\n:::\n\n\n> JSON (JavaScript Object Notation) is a light, readable data format that both humans and machines can readily parse and generate. Its structure consists of key-value pairs and arrays, making it a prevalent choice in web APIs and data interchange.\n\nAn API request mainly includes three components: the request endpoint, header, and body.\n\n1. An API endpoint refers to a specific URL or URI of a web service, serving as the access point for making requests and receiving responses from the API.\n\n2. Request Header: This contains supplemental details about the request, such as metadata or server instructions. It includes information like the HTTP method (GET, POST, PUT, DELETE), content type, authentication credentials, and more. Headers provide context or control the behavior of the API request.\n\n3. Request Body: This carries any data or parameters that need to be sent to the server with the API request. Primarily used for methods like POST, PUT, or PATCH, the body can contain various data formats such as JSON, XML, form data, or binary data, depending on the API's requirements.\n\nTogether, the request header and body allow for effective communication with an API, specifying the necessary information, desired action, data to be sent, and any additional instructions or authentication details.\n\nLet's add a header and body to a request:\n\n`http PUT pie.dev/put X-API-Token:123 name=John`\n\nHere, we're using a `PUT` *method* to send data to an API *endpoint* `pie.dev/put`, adding an X-API-Token `123` *header*, and specifying a 'name' field value as 'John' in the *body*. You will receive a JSON response with details on the successful POST request!\n\nIf this seems overwhelming, or you prefer a more convenient way to interact with APIs, I recommend using the HTTPie application or a service like PostMan, which provides a GUI.\n\n## Utilizing APIs in R\n\nIn R, APIs open the door to a wealth of intriguing datasets for your data analysis projects. Let's delve into API implementation in R using the `httr` and `jsonlite` packages.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(c(\"httr\", \"jsonlite\"))\n```\n:::\n\n\nOnce installed, load the packages:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(httr)\nlibrary(jsonlite)\n```\n:::\n\n\nLet's start interacting with APIs using the `GET()` function from the `httr` package. We'll extract data from the [Gutendex API](https://gutendex.com/), offering access to Project [Gutenberg](https://www.gutenberg.org/) ebook metadata. The code below fetches data from the API, particularly authors alive before 500 BCE (?author_year_end=-499):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nres <- GET(\"https://gutendex.com/books?author_year_end=-499\") \n```\n:::\n\n\nThe `GET()` function dispatches the HTTP GET request to the specified URL, and the API response gets stored in the `res` variable.\n\nInspect the response by printing the `res` object:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(res)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nResponse [https://gutendex.com/books/?author_year_end=-499]\n  Date: 2023-12-09 02:36\n  Status: 200\n  Content-Type: application/json\n  Size: 35.2 kB\n```\n:::\n:::\n\n\nThe next step is to parse the JSON response using `jsonlite`'s `fromJSON()` function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata <- fromJSON(rawToChar(res$content))\n```\n:::\n\n\n`rawToChar()` transmutes the raw Unicode content of the response into a character vector. Subsequently, `fromJSON()` transforms the character vector into a structured R object, such as a list or a data frame.\n\nDive into the acquired data by accessing its elements. For instance, you can display the book titles:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(data$results$title, n = 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"The Iliad\"                                                                                 \n[2] \"The Odyssey: Rendered into English prose for the use of those who cannot read the original\"\n[3] \"The Iliad\"                                                                                 \n[4] \"La Odisea\"                                                                                 \n[5] \"The Odyssey\"                                                                               \n```\n:::\n:::\n\n\nVoila! You've successfully made an API request in R and fetched data for further exploration.\n\n\n### Incorporating Request Body and Headers\n\nTo add a request body with the `query` parameter. In this example, we want authors alive before 500 BCE, Epic Poetry in French, and we add headers using the `add_headers()` function. Here as an example I set Key to Your Key:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(httr)\nlibrary(jsonlite)\n\n# Execute the POST request with the request body\nresponse <- GET(\n  url = \"https://gutendex.com/books\",\n  query = list(\n    author_year_end = -499,\n    topic = \"Epic Poetry\",\n    languages = \"fr\"\n  ),\n  add_headers(\"Key\" = \"Your Key\")\n)\n\nresponse |> \n  getElement(\"content\") |> \n  rawToChar() |> \n  fromJSON() |> \n  getElement(\"results\") |> \n  getElement(\"title\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"L'Odyss√©e\" \"L'Iliade\"  \"L'Odyss√©e\"\n```\n:::\n:::\n\n\nBy incorporating a request body or headers, you can furnish extra data or authentication details to your API requests.\n\nAlways refer to the API documentation for specific requirements and the headers available.\n\nKeep harnessing the power of APIs to access novel and compelling data sources for your projects!\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}