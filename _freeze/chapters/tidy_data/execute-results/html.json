{
  "hash": "b13f9510f87f11460512a6f9a69f9a5c",
  "result": {
    "markdown": "---\ntitle: \"Tidy Data\"\neditor: visual\n---\n\n\n\n::: {.cell}\n<style type=\"text/css\">\n.output {\nmax-height: 300px;\noverflow-y: scroll;\n}\n</style>\n:::\n\nTidy data is a standard way of structuring a dataset to streamline its usability. This standard, as popularized by Hadley Wickham [@wickhamTidyData2014], depends on the organization of rows, columns, and tables, and how they correspond to observations, variables, and types.\n\nIn the context of Tidy Data:\n\n1. Each variable is represented by a column.\n2. Each observation is represented by a row.\n3. Each type of observational unit is represented by a table.\n\n    > What changes put it in a column\n\nData commonly takes two formats: wide and long.\n\nWide data, also referred to as unstacked data, is structured so that each row represents an individual unit of observation, and each column represents a variable. This format is often employed when the number of variables is relatively small, and they don't share hierarchical relationships. This format is common in reports, where its readability excels. A notable example of wide data is a panel where columns correspond to years [@tbl-widepanel].\n\nIn contrast, long data, also known as stacked data, is organized so that each row represents a single observation of a variable, with columns representing the variable and the unit of observation identifier. This format is usually employed when the number of variables is large or they are hierarchically related. You'll often find that working with long data is much more manageable for conducting analyses.\n\n::: {#tbl-panel layout-ncol=\"2\"}\n| **Country** | **2020** | **2021** |\n|-------------|----------|----------|\n| USA         | 329.5    | 331.9    |\n| Russia      | 144.1    | 143.4    |\n| Mexico      | 126      | 126.7    |\n\n: Wide Format {#tbl-widepanel}\n\n| **Country** | **Year** | **Population** |\n|-------------|----------|----------------|\n| USA         | 2020     | 329.5          |\n| Russia      | 2020     | 144.1          |\n| Mexico      | 2020     | 126            |\n| USA         | 2021     | 331.9          |\n| Russia      | 2021     | 143.4          |\n| Mexico      | 2021     | 126.7          |\n\n: Tidy Long Format {#tbl-longpanel}\n\nPanel Data\n:::\n\nFrom the first example, one might think that long and tidy data are synonyms. Let's consider another example where we wish to make our data wider. In @tbl-across2, each observation—which comprises a country, its population, and birth rate—is spread across two rows. In this case, we aim to widen our data.\n\n::: {#tbl-widen layout-ncol=\"2\"}\n| Country | Name       | Value |\n|---------|------------|-------|\n| USA     | Population | 329.5 |\n| Russia  | Population | 144.1 |\n| Mexico  | Population | 126   |\n| USA     | Birth Rate | 1.64  |\n| Russia  | Birth Rate | 1.5   |\n| Mexico  | Birth Rate | 1.9   |\n\n: Across Two Rows {#tbl-across2}\n\n| Country | Population | Birth Rate |\n|---------|------------|------------|\n| USA     | 329.5      | 1.64       |\n| Russia  | 144.1      | 1.5        |\n| Mexico  | 126        | 1.9        |\n\n: Tidy Wide {#tbl-tidywide}\n\nMessy Long\n:::\n\nAnother common issue with messy data occurs when two variables are combined into one column, as seen in @tbl-gathered, where 'Year' and 'Population' are in the same column. These need to be separated into two distinct columns: 'Year' and 'Population'.\n\n::: {#tbl-gathersplit layout-ncol=\"2\"}\n| **Country** | **Year/Population** |\n|-------------|---------------------|\n| USA         | 2020/329.5          |\n| Russia      | 2020/144.1          |\n| Mexico      | 2020/126            |\n| USA         | 2021/331.9          |\n| Russia      | 2021/143.4          |\n| Mexico      | 2021/126.7          |\n\n: United Year/Population {#tbl-gathered}\n\n| Country | Year | Population |\n|---------|------|------------|\n| USA     | 2020 | 329.5      |\n| Russia  | 2020 | 144.1      |\n| Mexico  | 2020 | 126        |\n| USA     | 2021 | 331.9      |\n| Russia  | 2021 | 143.4      |\n| Mexico  | 2021 | 126.7      |\n\n: Tidy Split into Columns {#tbl-split}\n\nSeparate Data\n:::\n\n## Example\n\nTidy data is more than a theoretical concept; it has practical implications for data structuring. Consider this example of storing data on experiment payments:\n\n![](images/tidy_example1.png)\n\nWhen a computer reads this data, it can't understand our intent, so all columns are read as-is. Adding multiple days necessitates creating similar tables, increasing the chances of errors. Want a total for the entire experiment? We'd have to manually sum all cells. Now, compare this to:\n\n![](images/tidy_example2.png)\n\nIn this format, data input is straightforward, and generating summary tables is as simple as creating a pivot table. A tidy data approach from the outset aids in creating robust tables and saves time during analysis.\n\n## `pivot_longer()`\n\nA common problem arises in datasets where column names are not variable names, but *values* of a variable. This is the case for `pr_correct`, `tr_correct`, `ch_correct`, where the column names represent the `game` variable's name. Meanwhile, the values in the columns represent the number of correct answers, and each row denotes two observations, not one.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(data_raven <- readr::read_csv(\"https://raw.githubusercontent.com/nikitoshina/ECON-623-Lab-2023/main/data/mexico_sample_data.csv?token=GHSAT0AAAAAAB5WTPULI26TZP545VNUFQE6Y6O4XVA\") %>% select(id, mean_temp_celsius, gender, pr_correct, tr_correct, ch_tournament, ch_correct))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 114 × 7\n   id    mean_temp_celsius gender pr_correct tr_correct ch_tournament ch_correct\n   <chr>             <dbl> <chr>       <dbl>      <dbl>         <dbl>      <dbl>\n 1 0010…              28.6 Female          7          3             1          9\n 2 0010…              28.6 Male            5          6             0          4\n 3 0010…              28.6 Male            6          7             0          7\n 4 0010…              28.6 Male            1          5             1          7\n 5 0010…              28.6 Male            7          9             1         10\n 6 0010…              28.6 Female          2          7             0          5\n 7 0010…              28.6 Female          6          6             0          7\n 8 0010…              28.6 Female          7          7             0          6\n 9 0010…              30.7 Female          5          4             0          4\n10 0010…              30.7 Male            6          7             1          4\n# ℹ 104 more rows\n```\n:::\n:::\n\n\nTo tidy such a dataset, we need to pivot the problematic columns into a new pair of variables. This operation requires:\n\n1.  The columns whose names are values, not variables—columns we want to pivot. In this case, `pr_correct`, `tr_correct`, `ch_correct`.\n2.  The name of the variable where we'll move the column names. Here, it's `game`. The default is `name`.\n3.  The name of the variable where we'll move the column values. Here, it's `n_correct`. The default is `value`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_raven %>%\n  pivot_longer(c(pr_correct, tr_correct, ch_correct), names_to = \"game\", values_to = \"n_correct\") %>%\n  select(id, game, n_correct) %>%\n  head(n = 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 × 3\n  id        game       n_correct\n  <chr>     <chr>          <dbl>\n1 001018001 pr_correct         7\n2 001018001 tr_correct         3\n3 001018001 ch_correct         9\n4 001018002 pr_correct         5\n5 001018002 tr_correct         6\n```\n:::\n:::\n\n\n## `pivot_wider()`\n\n`pivot_wider()` is the opposite of `pivot_longer()`. It is used when an observation is scattered across multiple rows. For instance, consider the `data_raven_accident` dataset, where `mean_temp_celsius` and `ch_tournament` are stacked. In this case, an observation is spread across two rows.\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_raven_accident %>% head(n = 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 × 3\n  id        name              value\n  <chr>     <chr>             <dbl>\n1 001018001 mean_temp_celsius  28.6\n2 001018001 ch_tournament       1  \n3 001018002 mean_temp_celsius  28.6\n4 001018002 ch_tournament       0  \n5 001018005 mean_temp_celsius  28.6\n```\n:::\n:::\n\n\nTo tidy this up, we need two parameters:\n\n1.  The column to take variable names from. Here, it's `name`.\n2.  The column to take values from. Here it's `value`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_raven_accident %>%\n  pivot_wider(names_from = name, values_from = value) %>%\n  head(n = 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 × 3\n  id        mean_temp_celsius ch_tournament\n  <chr>                 <dbl>         <dbl>\n1 001018001              28.6             1\n2 001018002              28.6             0\n3 001018005              28.6             0\n4 001018009              28.6             1\n5 001018010              28.6             1\n```\n:::\n:::\n\n\nIt is evident from their names that `pivot_wider()` and `pivot_longer()` are inverse functions. `pivot_longer()` converts wide tables to a longer and narrower format, while `pivot_wider()` converts long tables to a shorter and wider format.\n\n## `separate()` and `unite()`\n\nSometimes, data may come with columns united, necessitating us to `separate()` them to maintain tidy data. The original function was superseded in favor of `separate_wider_position()` and `separate_wider_delim()`, there is also `separate_longer_*()` version.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_raven_sep %>% head(n = 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 × 2\n  id        `gender/pr_correct`\n  <chr>     <chr>              \n1 001018001 Female/7           \n2 001018002 Male/5             \n3 001018005 Male/6             \n4 001018009 Male/1             \n5 001018010 Male/7             \n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_raven_sep %>%\n  separate_wider_delim(col = \"gender/pr_correct\", delim = \"/\", names = c(\"gender\", \"pr_correct\")) %>%\n  head(n = 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 × 3\n  id        gender pr_correct\n  <chr>     <chr>  <chr>     \n1 001018001 Female 7         \n2 001018002 Male   5         \n3 001018005 Male   6         \n4 001018009 Male   1         \n5 001018010 Male   7         \n```\n:::\n:::\n\n\nWhat if we have one column that has been split across multiple columns? Consider a situation where our subject ID code, composed of site_id, session_n, and subject_n, has been broken down into three separate columns. In such a scenario, we would need to `unite()` these columns back into one.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_raven_uni %>% head(n = 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 × 4\n  site_id session_n subject_n gender\n  <chr>   <chr>     <chr>     <chr> \n1 001     018       001       Female\n2 001     018       002       Male  \n3 001     018       005       Male  \n4 001     018       009       Male  \n5 001     018       010       Male  \n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_raven_uni %>%\n  unite(c(site_id, session_n, subject_n), col = \"id\", sep = \"\") %>%\n  head(n = 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 × 2\n  id        gender\n  <chr>     <chr> \n1 001018001 Female\n2 001018002 Male  \n3 001018005 Male  \n4 001018009 Male  \n5 001018010 Male  \n```\n:::\n:::\n\n\n## `tibble()` and `tribble()`\n\nA tibble is a special kind of data frame in R. Tibbles are a modern re-imagining of the data frame, designed to be more friendly and consistent than traditional data frames. To create a tibble, we can use `tibble()`, similar to `data.frame()`. Here are some features that make tibbles unique:\n\n-   By default, tibbles display only the first 10 rows when printed, making them easier to work with large datasets.\n\n-   They use a consistent printing format, making it easier to work with multiple tibbles in the same session.\n\n-   Tibbles have a consistent subsetting behavior, making it easier to select columns by name. When printed, the data type of each column is specified.\n\n-   Subsetting a tibble will always return a tibble, so you don't need to use `drop = FALSE`, as you would with traditional data frames.\n\n-   Most importantly, tibbles can have columns that consist of lists.\n\nIn summary, Tibbles are a more modern and consistent version of data frames. They are less prone to errors and more readable, making them an excellent choice for data manipulation and exploration tasks.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntibble(\n  x = c(1, 2, 3),\n  y = c(\"one\", \"two\", \"three\")\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 2\n      x y    \n  <dbl> <chr>\n1     1 one  \n2     2 two  \n3     3 three\n```\n:::\n:::\n\n\nYou can also use `tribble()` to create a row-wise, readable tibble in R. This is especially useful when creating small tables of data. The syntax is as follows: `tribble(~column1, ~column2)`, where the Row column --- represents the data in a row by row layout.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntribble(\n  ~x, ~y,\n  1, \"one\",\n  2, \"two\",\n  3, \"three\"\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 2\n      x y    \n  <dbl> <chr>\n1     1 one  \n2     2 two  \n3     3 three\n```\n:::\n:::\n\n\n## `janitor`: Clean Your Data\n\nThe `janitor` package is designed to make the process of cleaning and tidying data as simple and efficient as possible. To learn more about the functions it provides, check out [this vignette](https://cran.r-project.org/web/packages/janitor/vignettes/janitor.html)!\n\n### `clean_names()`\n\nThe `clean_names()` function is used to clean variable names, especially those read in from Excel files using `readxl::read_excel()` and `readr::read_csv()`. It parses letter cases, separators, and special characters into a consistent format, converts certain characters like \"%\" to \"percent\" and \"#\" to \"number\" to retain meaning, and resolves issues of duplicate or empty names. It is recommended to call this function every time data is read.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create a data.frame with dirty names\ntest_df <- as.data.frame(matrix(ncol = 6))\nnames(test_df) <- c(\n  \"camelCase\", \"ábc@!*\", \"% of respondents (2009)\",\n  \"Duplicate\", \"Duplicate\", \"\"\n)\ntest_df %>% colnames()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"camelCase\"               \"ábc@!*\"                 \n[3] \"% of respondents (2009)\" \"Duplicate\"              \n[5] \"Duplicate\"               \"\"                       \n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(janitor)\ntest_df %>%\n  clean_names() %>%\n  colnames()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"camel_case\"                  \"abc\"                        \n[3] \"percent_of_respondents_2009\" \"duplicate\"                  \n[5] \"duplicate_2\"                 \"x\"                          \n```\n:::\n:::\n\n\n### `remove_empty()`\n\n`remove_empty()` removes empty rows and columns, which is especially useful after reading Excel files.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntest_df2 <- data.frame(\n  numbers = c(1, NA, 3),\n  food = c(NA, NA, NA),\n  letters = c(\"a\", NA, \"c\")\n)\ntest_df2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  numbers food letters\n1       1   NA       a\n2      NA   NA    <NA>\n3       3   NA       c\n```\n:::\n\n```{.r .cell-code}\ntest_df2 %>%\n  remove_empty(c(\"rows\", \"cols\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  numbers letters\n1       1       a\n3       3       c\n```\n:::\n:::\n\n\n### `remove_constant()`\n\n`remove_constant()` drops columns from a data.frame that contain only a single constant value (with an na.rm option to control whether `NAs` should be considered as different values from the constant).\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntest_df3 <- data.frame(cool_numbers = 1:3, boring = \"the same\")\ntest_df3\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  cool_numbers   boring\n1            1 the same\n2            2 the same\n3            3 the same\n```\n:::\n\n```{.r .cell-code}\ntest_df3 %>% remove_constant()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  cool_numbers\n1            1\n2            2\n3            3\n```\n:::\n:::\n\n\n### `convert_to_date()` and `convert_to_datetime()` \n\nDo you remember loading data from Excel and seeing `36922.75` instead of dates? Well, `convert_to_date()` and `convert_to_datetime()` will convert this format and other date-time formats to actual dates! If you need more customization, check `excel_numeric_to_date()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nconvert_to_date(36922.75)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2001-01-31\"\n```\n:::\n\n```{.r .cell-code}\nconvert_to_datetime(36922.75)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2001-01-31 18:00:00 UTC\"\n```\n:::\n:::\n\n\n### `row_to_names()` \n\n`row_to_names()` is a function that takes the names of variables stored in a row of a data frame and makes them the column names of the data frame. It can also remove the row that contained the names, and any rows above it, if desired.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntest_df4 <- data.frame(\n  x_1 = c(NA, \"Names\", 1:3),\n  x_2 = c(NA, \"Value\", 4:6)\n)\ntest_df4\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    x_1   x_2\n1  <NA>  <NA>\n2 Names Value\n3     1     4\n4     2     5\n5     3     6\n```\n:::\n\n```{.r .cell-code}\nrow_to_names(test_df4, 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  Names Value\n3     1     4\n4     2     5\n5     3     6\n```\n:::\n:::\n\n\n## Summary\n\nThis chapter introduced the concept of tidy data, focusing on its structured format where each variable corresponds to a column, each observation to a row, and each observational unit type to a table. We highlighted the distinctions between wide and long data formats, and delved into practical R tools for organizing data into this tidy structure, including an overview of tibbles and additional resources for data cleaning. Understanding these principles of tidy data is invaluable and will prove beneficial throughout your career. Next, we will shift our focus to relational data and the concept of joins!",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}