{
  "hash": "8d44d199ae719d62c169e6f90d4c1937",
  "result": {
    "markdown": "---\ntitle: \"Data Manipulation\"\neditor: visual\n\n---\n\n\n\n::: {.cell}\n<style type=\"text/css\">\n.output {\nmax-height: 300px;\noverflow-y: scroll;\n}\n</style>\n:::\n\nIn the realm of data analysis, data visualization and manipulation are indispensable tools for understanding and communicating complex information. R, being a potent programming language for data analysis, provides an array of packages that allow creation of visually striking plots and facilitate efficient data manipulation. Tidyverse, one of the most user-friendly and widely used collections of R packages^[A package is a collection of pre-written functions, data, and documentation that enhances the capabilities of the R programming language for specific tasks.], has been developed by Hadley Wickham, the Chief Scientist at Posit (RStudio). Tidyverse encompasses packages catering to all common tasks, which can be installed and activated using `install.packages(\"tidyverse\")` and `library(\"tidyverse\")` respectively. In this introduction, we will delve into the basics of Tidyverse, utilizing `readr` for data reading, `dplyr` for manipulation, `tidyr` for tidying, and later in the book `ggplot2` for visualization. To explore more about Tidyverse, visit their website <https://www.tidyverse.org/>.\n\n## Basics\n\nLet's kick off with some fundamental concepts! R can be employed as a simple calculator.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# A \"#\" is used to annotate comments!\n2 + 2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4\n```\n:::\n\n```{.r .cell-code}\n2 * 4\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 8\n```\n:::\n\n```{.r .cell-code}\n2^8\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 256\n```\n:::\n\n```{.r .cell-code}\n(1 + 3) / (3 + 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.5\n```\n:::\n\n```{.r .cell-code}\nlog(10) # Calculates the natural log of 10!\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2.302585\n```\n:::\n:::\n\n\nR allows for defining variables and performing operations on them. Both `=` or `<-` can be used for assigning values to a variable name, though `<-` is  preferred to evade confusion and certain errors.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 2 # Equivalent to x = 2\nx * 4\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 8\n```\n:::\n:::\n\n\nThe command `x <- 2` assigns the value `2` to `x`. Thus, when we subsequently type `x * 4`, R substitutes `x` with `2` to evaluate `2 * 4` and obtain `8`. The value of `x` can be updated as needed using `=` or `<-`. Bear in mind that R is case sensitive, so `X` and `x` are recognized as different variables.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2\n```\n:::\n\n```{.r .cell-code}\nx <- x * 5\n```\n:::\n\n\n### Data Types\n\nR possesses a multitude of data types and classes, including `data.frames` which are akin to Excel spreadsheets with columns and rows. Initially, we'll examine vectors. Vectors can store multiple values of the same type, with the most basic ones being numeric, character, and logical.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 10\n```\n:::\n\n```{.r .cell-code}\nclass(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"numeric\"\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n(name <- \"Parsa Rahimi\") # <1>\nclass(name)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Parsa Rahimi\"\n[1] \"character\"\n```\n:::\n:::\n\n1. Wrapping with (...) prints the variable\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(true_or_false <- TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\nclass(true_or_false)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"logical\"\n```\n:::\n:::\n\n\nNote that `name` is stored as a single character string. If we want to store the name and surname separately in the same object, we can employ `c()` to concatenate objects of similar class into a vector.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(name_surname <- c(\"Parsa\", \"Rahimi\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Parsa\"  \"Rahimi\"\n```\n:::\n\n```{.r .cell-code}\nlength(name)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n\n```{.r .cell-code}\nlength(name_surname)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2\n```\n:::\n:::\n\n\nObserve that the length of `name` is 1 and that of `name_surname` is 2! Let's create a numeric vector and perform some operations on it!\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(i <- c(1, 2, 3, 4))\ni + 10 # <1>\ni * 10 # <2>\ni + c(2, 4, 6, 8) # <3>\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3 4\n[1] 11 12 13 14\n[1] 10 20 30 40\n[1]  3  6  9 12\n```\n:::\n:::\n\n1. Adds 10 to each element\n2. Multiplies each element by 10\n3. Adds together elements in corresponding positions\n\nThe operations performed above don't modify `i`. The results are merely printed, not stored. If we wish to save the results, we must assign them to a variable.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nname\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Parsa Rahimi\"\n```\n:::\n\n```{.r .cell-code}\nname <- i + c(5, 4, 2, 1)\nname\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 6 6 5 5\n```\n:::\n:::\n\n\nNotice that `name` is no longer \"Parsa Rahimi\". It was overwritten by a numeric vector rather than a character string. Make sure to perform numeric operations only on numeric objects to avoid errors. The `str()` function can be used to obtain the structure of the object, such as type, length, etc.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nname_surname + 2\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in name_surname + 2: non-numeric argument to binary operator\n```\n:::\n\n```{.r .cell-code}\nstr(name_surname)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n chr [1:2] \"Parsa\" \"Rahimi\"\n```\n:::\n:::\n\n\n## Downloading Data\n\nIf you're accustomed to Base R (i.e., functions that come with R upon installation), you may be aware of `read.csv()`. However, `readr`, a part of the Tidyverse package, offers functions that address common issues associated with Base R's reading functions. `read_csv` not only loads data 10 times faster than `read.csv`, but it also produces a tibble instead of a data frame and evades inconsistencies of `read.csv`. You might be asking, \"What exactly is a tibble?\" A tibble is a special type of data frame with several advantages, such as faster loading times, maintaining input types, permitting columns as lists, allowing non-standard variable names, and never creating row names.\n\nTo load your data, you first need to know the path to your data. You can find your file, check its location, and then copy and paste it. If you are a Windows user, your path might contain \"\\\\\", which is an escape character. To rectify this, replace \"\\\\\" with \"/\". Copying the path gives you the absolute path (e.g., `\"/Users/User/Documents/your_project/data/file.csv\"`), but you can also use a local path from the folder of the project (e.g., `\"/data/file.csv\"`). Let's read the data! Using `readr::` specifies which package to use. \n\n### Example Data\n\nIn this tutorial, I'll be using a real sample from the Climate and Cooperation Experiment conducted in Mexico. During the experiment, subjects were asked to complete three series of Raven's matrices, four dictator games, and a single lottery game in rooms with varying temperatures. We will primarily be using results from the Raven's matrices games, which consist of 3 sets of 12 matrices. The first set, `pr_`, is the piece-rate round where participants received points for each correctly solved matrix. The second set, `tr_`, is the tournament round where participants competed against a random opponent. The winner received double points, and the loser received nothing. The third set, `ch_`, is the choice round where participants chose whether they wanted to play the piece-rate or tournament round against a different opponent's score from the tournament round.\n\nThe data is located in the `data` directory of the GitHub repository. To access and manipulate it, we will require the `tidyverse` package. This package includes several sub-packages, including `reader`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n:::\n\n::: {.cell hash='data_manipulation_cache/html/unnamed-chunk-14_b2f58067f521567c73fd9c3536290d50'}\n\n```{.r .cell-code}\ndata <- readr::read_csv(\"https://raw.githubusercontent.com/nikitoshina/quarto_book/main/chapters/data/experiment_data.csv\") # <1>\n```\n:::\n\n1. Download data from GitHub\n\nTo get a glimpse of the data, we can use the `glimpse()` function, which will provide us with a sample and the type of the column. Another common method is to use `head()` to get a slice of the top rows or `tail()` to get a slice of the bottom rows. To view the entire data set, use `View()`.\n\n\n::: {.cell .output}\n\n```{.r .cell-code}\ndata %>% glimpse()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 114\nColumns: 7\n$ id                <chr> \"001018001\", \"001018002\", \"001018005\", \"001018009\", …\n$ mean_temp_celsius <dbl> 28.58772, 28.58772, 28.58772, 28.58772, 28.58772, 28…\n$ gender            <chr> \"Female\", \"Male\", \"Male\", \"Male\", \"Male\", \"Female\", …\n$ pr_correct        <dbl> 7, 5, 6, 1, 7, 2, 6, 7, 5, 6, 8, 2, 2, 5, 6, 5, 2, 6…\n$ tr_correct        <dbl> 3, 6, 7, 5, 9, 7, 6, 7, 4, 7, 6, 3, 6, 7, 8, 6, 6, 8…\n$ ch_tournament     <dbl> 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0…\n$ ch_correct        <dbl> 9, 4, 7, 7, 10, 5, 7, 6, 4, 4, 8, 6, 5, 6, 6, 6, 5, …\n```\n:::\n:::\n\n\n## Basic Data Management With `dplyr`\n\n`dplyr` uses a collection of verbs to manipulate data that are piped (chained) into each other with a piping operator `%>%` from `magrittr` package. The way you use functions in base R is you wrap new function over the previous one, such as `k(g(f(x)))` this will become impossible to read very quickly as you stack up functions and their arguments. To solve this we will use pipes `x %>% f() %>% g() %>% k()`! Now you can clearly see that we take `x` and apply `f()`, then `g()`, then `k()`. \n\n> Note: base R now also has its own pipe `|>`, but we will stick to `%>%` for compatibility across packages.\n\n### `select()`\n\n`select()` selects only the columns that you want, removing all other columns. You can use column position (with numbers) or name. The columns will be displayed in the order you list them. We will select `subject_id`, `temperature`, `gender` and results of raven's matrices games.\n\n-   `id` is a unique subject identification number, where site_id.session_n.subject_n (001.001.001).\n-   `mean_temp_celsius` is mean temperature through the session\n-   `gender` is gender of the subject.\n-   `pr_correct` is number of correct answers in *piece-rate* round.\n-   `tr_correct` is number of correct answers in *tournament* round.\n-   `ch_correct` is number of correct answers in *choice* round.\n-   `ch_tournament` is 1 if participant decided to play tournament and 0 if choice.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_raven <- data %>% select(id, mean_temp_celsius, gender, pr_correct, tr_correct, ch_tournament, ch_correct)\ntail(data_raven)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 7\n  id     mean_temp_celsius gender pr_correct tr_correct ch_tournament ch_correct\n  <chr>              <dbl> <chr>       <dbl>      <dbl>         <dbl>      <dbl>\n1 00102…              30.5 Female          6          8             1          6\n2 00102…              30.5 Male            6          5             0          3\n3 00102…              30.5 Male            6          6             1          4\n4 00102…              30.5 Female          6          7             0          6\n5 00102…              30.5 Female          6          7             0          5\n6 00102…              30.5 Male            4          7             0          7\n```\n:::\n:::\n\n\nYou can also exclude columns or select everything else with select using `-`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_raven %>%\n  select(-gender) %>%\n  head()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 6\n  id        mean_temp_celsius pr_correct tr_correct ch_tournament ch_correct\n  <chr>                 <dbl>      <dbl>      <dbl>         <dbl>      <dbl>\n1 001018001              28.6          7          3             1          9\n2 001018002              28.6          5          6             0          4\n3 001018005              28.6          6          7             0          7\n4 001018009              28.6          1          5             1          7\n5 001018010              28.6          7          9             1         10\n6 001018013              28.6          2          7             0          5\n```\n:::\n:::\n\n\n### `filter()`\n\nThe `filter()` function helps us keep only the rows we need, based on certain rules. For example, we use it here to make two separate groups of data: one for Males and another for Females. We use `==` to check one-to-one equality. Also, you can use symbols like `<`, `<=`, `>`, `>=`, and `%in%`. The `%in%` symbol is special – it checks if a value is part of a list.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_male <- data_raven %>% filter(gender == \"Male\")\ndata_female <- data_raven %>% filter(gender == \"Female\")\nhead(data_male)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 7\n  id     mean_temp_celsius gender pr_correct tr_correct ch_tournament ch_correct\n  <chr>              <dbl> <chr>       <dbl>      <dbl>         <dbl>      <dbl>\n1 00101…              28.6 Male            5          6             0          4\n2 00101…              28.6 Male            6          7             0          7\n3 00101…              28.6 Male            1          5             1          7\n4 00101…              28.6 Male            7          9             1         10\n5 00101…              30.7 Male            6          7             1          4\n6 00101…              30.7 Male            5          6             1          6\n```\n:::\n\n```{.r .cell-code}\nhead(data_female)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 7\n  id     mean_temp_celsius gender pr_correct tr_correct ch_tournament ch_correct\n  <chr>              <dbl> <chr>       <dbl>      <dbl>         <dbl>      <dbl>\n1 00101…              28.6 Female          7          3             1          9\n2 00101…              28.6 Female          2          7             0          5\n3 00101…              28.6 Female          6          6             0          7\n4 00101…              28.6 Female          7          7             0          6\n5 00101…              30.7 Female          5          4             0          4\n6 00101…              30.7 Female          8          6             1          8\n```\n:::\n:::\n\n\nYou can chain multiple criteria. In the example below, we filter for Males with temperatures above 30 degrees Celsius and Females with temperatures below 30 degrees Celsius. We use `&` for \"and\" and `|` for \"or\", and enclose the conditions in parentheses to avoid confusion.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_raven %>%\n  filter(\n    (gender == \"Male\" & mean_temp_celsius > 30) | (gender == \"Female\" & mean_temp_celsius < 30)\n  ) %>%\n  head()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 7\n  id     mean_temp_celsius gender pr_correct tr_correct ch_tournament ch_correct\n  <chr>              <dbl> <chr>       <dbl>      <dbl>         <dbl>      <dbl>\n1 00101…              28.6 Female          7          3             1          9\n2 00101…              28.6 Female          2          7             0          5\n3 00101…              28.6 Female          6          6             0          7\n4 00101…              28.6 Female          7          7             0          6\n5 00101…              30.7 Male            6          7             1          4\n6 00101…              30.7 Male            5          6             1          6\n```\n:::\n:::\n\n\n### `arrange()`\n\nThe `arrange()` function orders the table using a variable. For example, to see the subject with the lowest score in `pr_correct`, we can use:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_raven %>%\n  arrange(pr_correct) %>%\n  head()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 7\n  id     mean_temp_celsius gender pr_correct tr_correct ch_tournament ch_correct\n  <chr>              <dbl> <chr>       <dbl>      <dbl>         <dbl>      <dbl>\n1 00101…              28.6 Male            1          5             1          7\n2 00101…              28.6 Female          2          7             0          5\n3 00101…              30.7 Female          2          3             0          6\n4 00101…              30.7 Female          2          6             0          5\n5 00101…              30.7 Male            2          6             1          5\n6 00102…              30.4 Male            2          3             1          2\n```\n:::\n:::\n\n\nTo sort in descending order, use the `desc()` modifier. For example, to find the subject with the highest score:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_raven %>%\n  arrange(desc(pr_correct)) %>%\n  head()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 7\n  id     mean_temp_celsius gender pr_correct tr_correct ch_tournament ch_correct\n  <chr>              <dbl> <chr>       <dbl>      <dbl>         <dbl>      <dbl>\n1 00101…              30.7 Female          8          6             1          8\n2 00102…              31.6 Male            8          6             1          5\n3 00102…              31.6 Male            8          7             0          7\n4 00102…              30.4 Male            8          4             0          7\n5 00102…              26.8 Male            8          9             1          9\n6 00102…              32.2 Female          8          7             0          8\n```\n:::\n:::\n\n\n### `mutate()`\n\nThe `mutate()` function adds new columns or modifies existing ones in the dataset. For instance, you can create a dataset with 4 rows and add three new variable columns:\n\n\n::: {.cell .output}\n\n```{.r .cell-code}\ntibble(rows = 1:4) %>% mutate(\n  One = 1,\n  Comment = \"Something\",\n  Approved = TRUE\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 × 4\n   rows   One Comment   Approved\n  <int> <dbl> <chr>     <lgl>   \n1     1     1 Something TRUE    \n2     2     1 Something TRUE    \n3     3     1 Something TRUE    \n4     4     1 Something TRUE    \n```\n:::\n:::\n\n\nYou can use `mutate()` to create new variables using existing ones. For instance, you can convert Celsius to Fahrenheit, calculate the improvement in tournament scores over piece-rate round scores, and check the deviation from the mean score in the piece-rate round:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_raven %>% mutate(\n  mean_temp_fahrenheit = (mean_temp_celsius * 9 / 5) + 32,\n  impovement = tr_correct - pr_correct,\n  pr_deviation = pr_correct - mean(pr_correct)\n) %>% \n  head()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 10\n  id     mean_temp_celsius gender pr_correct tr_correct ch_tournament ch_correct\n  <chr>              <dbl> <chr>       <dbl>      <dbl>         <dbl>      <dbl>\n1 00101…              28.6 Female          7          3             1          9\n2 00101…              28.6 Male            5          6             0          4\n3 00101…              28.6 Male            6          7             0          7\n4 00101…              28.6 Male            1          5             1          7\n5 00101…              28.6 Male            7          9             1         10\n6 00101…              28.6 Female          2          7             0          5\n# ℹ 3 more variables: mean_temp_fahrenheit <dbl>, impovement <dbl>,\n#   pr_deviation <dbl>\n```\n:::\n:::\n\n\nNotice how we can nest functions within `mutate()` to first calculate the mean of an entire column and then subtract it from `pr_correct`.\n\n### `case_match()`\n\nThe `case_match()` function modifies values within a variable. For example, we can use `case_match()` to change \"Male\" to \"M\" and \"Female\" to \"F\":\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_raven <- data_raven %>% mutate(gender = case_match(gender, \"Male\" ~ \"M\", \"Female\" ~ \"F\"))\n```\n:::\n\n\n### `summarize()`\n\nThe `summarize()` function reduces all rows into a one-row summary. It can be used to calculate the percentage of participants who were male, the median score in the piece-rate round, the maximum score in the tournament, the percentage of people choosing the tournament in choice round, and the mean score in the choice round.\n\nIn dplyr 1.0.0, `reframe()` was introduced. Unlike `summarize()`, `reframe()` can produce multiple row outputs. Use `summarize()` when expecting one row per group and `reframe()` for multiple rows.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_raven %>%\n  summarize(\n    prop_male = sum(gender == \"M\", na.rm = T) / n(),\n    pr_median = median(pr_correct),\n    tr_max = max(tr_correct),\n    ch_ratio = sum(ch_tournament) / n(),\n    ch_mean = mean(ch_correct)\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 5\n  prop_male pr_median tr_max ch_ratio ch_mean\n      <dbl>     <dbl>  <dbl>    <dbl>   <dbl>\n1     0.482         5      9    0.456    6.01\n```\n:::\n:::\n\n\n### `group_by()`\n\nThe `group_by()` function groups data by specific variables for subsequent operations. By combining `group_by()` and `summarize()`, you can calculate different summary statistics for genders!\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_raven %>%\n  drop_na(gender) %>%\n  group_by(gender) %>%\n  summarize(\n    pr_mean = mean(pr_correct),\n    tr_mean = mean(tr_correct),\n    ch_mean = mean(ch_correct),\n    pr_sd = sd(pr_correct),\n    n = n()\n  ) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 6\n  gender pr_mean tr_mean ch_mean pr_sd     n\n  <chr>    <dbl>   <dbl>   <dbl> <dbl> <int>\n1 F         5.22    6.17    5.93  1.58    58\n2 M         5.47    6.4     6.09  1.59    55\n```\n:::\n:::\n\n\nNow, let's group by gender and choice in the choice round to look at points in the choice round!\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_raven %>%\n  drop_na(gender) %>%\n  group_by(gender, ch_tournament) %>%\n  summarize(\n    ch_mean = mean(ch_correct),\n    pr_sd = sd(ch_correct),\n    n = n()\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 × 5\n# Groups:   gender [2]\n  gender ch_tournament ch_mean pr_sd     n\n  <chr>          <dbl>   <dbl> <dbl> <int>\n1 F                  0    5.73  1.70    33\n2 F                  1    6.2   1.73    25\n3 M                  0    6.07  1.69    29\n4 M                  1    6.12  2.25    26\n```\n:::\n:::\n\n\n### `ungroup()`\n\nThe `ungroup()` function removes grouping. Always ungroup your data after performing operations that required grouping to avoid confusion.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_raven %>%\n  drop_na(gender) %>%\n  group_by(gender) %>%\n  mutate(n = n()) %>%\n  summarize(mean_male = mean(gender == \"M\")) %>%\n  ungroup() \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 2\n  gender mean_male\n  <chr>      <dbl>\n1 F              0\n2 M              1\n```\n:::\n:::\n\n\nNotice how `mean_male` (the ratio of males to the total) is 0 for Female and 1 for Male. That's because the data was grouped, and we performed operations on Males and Females separately.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_raven %>%\n  drop_na(gender) %>%\n  group_by(gender) %>%\n  mutate(n = n()) %>%\n  ungroup() %>%\n  summarize(mean_male = mean(gender == \"M\")) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 1\n  mean_male\n      <dbl>\n1     0.487\n```\n:::\n:::\n\n\nThis time, we ungrouped the data before calculating the ratio, which gives us the correct result!\n\n### `.by`\n\nGrouping is a commonly performed operation. Having to repeatedly group and ungroup for individual operations can lead to verbosity. To address this, `dplyr` introduced a convenient feature with version 1.0.0 — the `.by` argument within `dplyr` functions. This enhancement streamlines the process and reduces the need for excessive grouping and ungrouping.\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 113 × 8\n   id    mean_temp_celsius gender pr_correct tr_correct ch_tournament ch_correct\n   <chr>             <dbl> <chr>       <dbl>      <dbl>         <dbl>      <dbl>\n 1 0010…              28.6 F               7          3             1          9\n 2 0010…              28.6 M               5          6             0          4\n 3 0010…              28.6 M               6          7             0          7\n 4 0010…              28.6 M               1          5             1          7\n 5 0010…              28.6 M               7          9             1         10\n 6 0010…              28.6 F               2          7             0          5\n 7 0010…              28.6 F               6          6             0          7\n 8 0010…              28.6 F               7          7             0          6\n 9 0010…              30.7 F               5          4             0          4\n10 0010…              30.7 M               6          7             1          4\n# ℹ 103 more rows\n# ℹ 1 more variable: n <int>\n```\n:::\n:::\n\n1. same as `group_by %>% mutate %>% ungroup`\n\n\n### `rowwise()`\n\nThe `rowwise()` function allows for row-wise grouping. There may be situations where you want to perform a calculation row-wise instead of column-wise. However, when you try to perform the operation, you get an aggregate result. `rowwise()` comes to your rescue in such situations. Let's create a dataframe with a column of lists and try to find the length of each list:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- tibble(\n  x = list(1, 2:3, 4:6, 7:11)\n)\n\ndf %>% mutate(length = length(x))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 × 2\n  x         length\n  <list>     <int>\n1 <dbl [1]>      4\n2 <int [2]>      4\n3 <int [3]>      4\n4 <int [5]>      4\n```\n:::\n:::\n\n\nIn the example above, instead of obtaining the lengths of the lists, we got the total number of rows in the dataset (the length of column `x`). Now, let's use `rowwise()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf %>%\n  rowwise() %>%\n  mutate(length = length(x))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 × 2\n# Rowwise: \n  x         length\n  <list>     <int>\n1 <dbl [1]>      1\n2 <int [2]>      2\n3 <int [3]>      3\n4 <int [5]>      5\n```\n:::\n:::\n\n\nWith `rowwise()`, R runs the `length()` function on each list separately, providing the correct lengths. Alternatively, you can use `lengths()`, which applies `length()` to each list.\n\n> Or you can use `lengths()`.\n\n### `count()`\n\n`count()` function in R is used for counting the number of rows within each group of values, similar to a combination of `group_by()` and `summarize()` functions. It can be used with a single column:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_raven %>% count(gender)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 2\n  gender     n\n  <chr>  <int>\n1 F         58\n2 M         55\n3 <NA>       1\n```\n:::\n:::\n\nOr with multiple columns:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_raven %>% count(gender, ch_tournament)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 × 3\n  gender ch_tournament     n\n  <chr>          <dbl> <int>\n1 F                  0    33\n2 F                  1    25\n3 M                  0    29\n4 M                  1    26\n5 <NA>               1     1\n```\n:::\n:::\n\n\n### `rename()`\n\nThe `rename()` function allows you to change column names, with the new name on the left and the old name on the right:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_raven %>%\n  rename(subject_id = id, sex = gender) %>%\n  head(5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 × 7\n  subject_id mean_temp_celsius sex   pr_correct tr_correct ch_tournament\n  <chr>                  <dbl> <chr>      <dbl>      <dbl>         <dbl>\n1 001018001               28.6 F              7          3             1\n2 001018002               28.6 M              5          6             0\n3 001018005               28.6 M              6          7             0\n4 001018009               28.6 M              1          5             1\n5 001018010               28.6 M              7          9             1\n# ℹ 1 more variable: ch_correct <dbl>\n```\n:::\n:::\n\n\n### `row_number()`\n\n`row_number()` generates a column with consecutive numbers, which can be useful for creating a new id column. The following example first removes the `id` column, then creates a new one using `row_number()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_raven %>%\n  select(-id) %>%\n  mutate(id = row_number()) %>%\n  relocate(id) %>%\n  head(5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 × 7\n     id mean_temp_celsius gender pr_correct tr_correct ch_tournament ch_correct\n  <int>             <dbl> <chr>       <dbl>      <dbl>         <dbl>      <dbl>\n1     1              28.6 F               7          3             1          9\n2     2              28.6 M               5          6             0          4\n3     3              28.6 M               6          7             0          7\n4     4              28.6 M               1          5             1          7\n5     5              28.6 M               7          9             1         10\n```\n:::\n:::\n\n\n\n### `skim()`\n\n`skim()` from the `skimr` package provides an extensive summary of a data frame. It offers more than `summary()`, detailing quartiles, missing values, and histograms. Use it during exploratory data analysis to understand your data. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(skimr)\nskim(data_raven)\n```\n\n::: {.cell-output-display}\nTable: Data summary\n\n|                         |           |\n|:------------------------|:----------|\n|Name                     |data_raven |\n|Number of rows           |114        |\n|Number of columns        |7          |\n|_______________________  |           |\n|Column type frequency:   |           |\n|character                |2          |\n|numeric                  |5          |\n|________________________ |           |\n|Group variables          |None       |\n\n\n**Variable type: character**\n\n|skim_variable | n_missing| complete_rate| min| max| empty| n_unique| whitespace|\n|:-------------|---------:|-------------:|---:|---:|-----:|--------:|----------:|\n|id            |         0|          1.00|   9|   9|     0|      114|          0|\n|gender        |         1|          0.99|   1|   1|     0|        2|          0|\n\n\n**Variable type: numeric**\n\n|skim_variable     | n_missing| complete_rate|  mean|   sd|    p0|  p25|   p50|   p75| p100|hist  |\n|:-----------------|---------:|-------------:|-----:|----:|-----:|----:|-----:|-----:|----:|:-----|\n|mean_temp_celsius |         0|             1| 30.63| 1.43| 26.84| 30.4| 30.69| 31.59| 32.3|▁▁▂▇▆ |\n|pr_correct        |         0|             1|  5.34| 1.57|  1.00|  5.0|  5.00|  6.00|  8.0|▁▂▇▅▅ |\n|tr_correct        |         0|             1|  6.28| 1.35|  3.00|  6.0|  6.00|  7.00|  9.0|▃▃▇▇▃ |\n|ch_tournament     |         0|             1|  0.46| 0.50|  0.00|  0.0|  0.00|  1.00|  1.0|▇▁▁▁▇ |\n|ch_correct        |         0|             1|  6.01| 1.82|  2.00|  5.0|  6.00|  7.00| 10.0|▃▃▅▇▁ |\n:::\n:::\n\n\nIt provides a neat, comprehensive view of each variable, useful for further analysis.\n\n## Exploring Date and Time with `lubridate`\n\nNavigating the complexities of dates, times, and timezones can be a daunting task, but fear not! The `lubridate` package, a recent addition to the `tidyverse`, comes to the rescue with its remarkable capabilities for simplifying date and time manipulations. With `lubridate`, you can effortlessly convert strings into dates, dates into strings, alter formats, check for overlaps, and perform date arithmetic.\n\n### `ymd()`, `md()`, `hms()`, `ymd_hms()`\n\nWhen working with dates, various notations exist, each represented by a combination of letters. To extract dates from text, all you need is to discern the order of year, month, day, hours, minutes, and seconds, and then employ the corresponding function to work your magic.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(lubridate)\nday_year_month <- \"31/2001/01\"\n(date <- dym(day_year_month))\n\nmonth_day_year_hour_minute <- \"Jan 31st 2001 6:05PM\"\n(date_time <- mdy_hm(month_day_year_hour_minute))\n\nsentence_with_date <- \"Elizabeth II was Queen of the United Kingdom and other Commonwealth realms from 6 February 1952.\"\ndmy(sentence_with_date) # <1>\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2001-01-31\"\n[1] \"2001-01-31 18:05:00 UTC\"\n[1] \"1952-02-06\"\n```\n:::\n:::\n\n1. Impressive, isn't it? `lubridate` can identify the date within text and parse it for you!\n\n### `year()`, `month()`, `day()`\n\nSimilarly, you can extract specific date and time components using functions aptly named after the elements you wish to retrieve.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nday(date_time)\nhour(date_time)\nmonth(date_time, label = TRUE, abbr = FALSE) # <1>\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 31\n[1] 18\n[1] January\n12 Levels: January < February < March < April < May < June < ... < December\n```\n:::\n:::\n\n1. Setting `label = TRUE` provides the month's name, while `abbr = FALSE` yields the full name.\n\n## Summary\n\nWe explored basic operations in R and delved into the key features of Tidyverse for data manipulation. This included learning how to load, manage, and handle basic date and time data. This chapter lays a solid foundation for beginners. Next, we will delve into what constitutes tidy data and how to organize data effectively.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}