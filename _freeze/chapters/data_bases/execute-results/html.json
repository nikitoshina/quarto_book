{
  "hash": "0c71308c4f8ba41b388250400d1b27a6",
  "result": {
    "markdown": "---\ntitle: \"Relational Databases\"\neditor: visual\n---\n\n\nA database is an organized collection of data that can be easily stored, managed, updated, and retrieved. One such type is the relational database, which structures data into tables consisting of rows and columns. Each row, also known as a record, encapsulates information about a single entity, while each column, or attribute, defines a specific aspect of that entity.\n\nRelational databases employ tables and relationships between these tables to store data. A row signifies a unique instance of a table's subject, while a column represents a distinct characteristic of the subject.\n\nFor example, consider the following table:\n\n| Student ID | Student Name | HW1 | HW2 | MidTerm |\n|------------|--------------|-----|-----|---------|\n| 20101002   | Nikita       | 88  | 100 | 76      |\n| 20101003   | Nelson       | 78  | 98  | 100     |\n| 20101004   | Parsa        | 98  | 99  | 95      |\n| 20101005   | Shivani      | 56  | 80  | 76      |\n\nWhen rows from one table can be associated with rows in another table, the tables are understood to share a relationship.\n\n## Relationship Types {#sec-relationships}\n\n### One to One (1:1)\n\nIn a one-to-one relationship, a single row in the first table corresponds to just one row in the second table, and vice versa. For example, the relationship between Countries and their respective Capitals:\n\n\n```{dot}\ndigraph G {\nrankdir = \"LR\";\nnode [shape=plaintext];\nsplines=polyline;\nedge [minlen=1.5];\n\nsubgraph cluster_0 {\ncolor=white;\nrank=same;\nTable1 [label=<\n<table border=\"1\" cellborder=\"0\" cellspacing=\"0\">\n<tr><td bgcolor=\"lightblue\"><b>Country</b></td></tr>\n<tr><td PORT=\"row11\">China</td></tr>\n<tr><td PORT=\"row12\">France</td></tr>\n<tr><td PORT=\"row13\">Italy</td></tr>\n</table>\n>];\n}\n \n\n\n\nsubgraph cluster_1 {\ncolor=white;\nrank=same;\nTable2 [label=<\n<table border=\"1\" cellborder=\"0\" cellspacing=\"0\">\n<tr><td bgcolor=\"lightblue\"><b>Capital</b></td></tr>\n<tr><td PORT=\"row21\">Beijing</td></tr>\n<tr><td PORT=\"row22\">Paris</td></tr>\n<tr><td PORT=\"row23\">Rome</td></tr>\n</table>\n>];\n}\n\nTable1:row11:e -> Table2:row21:w;\nTable1:row12:e -> Table2:row22:w;\nTable1:row13:e -> Table2:row23:w;\n\n}\n```\n\n\n### One to Many (1:M)\n\nIn a one-to-many relationship, a single row in the first table can be linked to multiple rows in the second table, but a row in the second table is related to only one row in the first table. For instance, one Professor can teach several Classes:\n\n\n```{dot}\ndigraph G {\nrankdir = \"LR\";\nnode [shape=plaintext];\nsplines=polyline;\nedge [minlen=1.5];\n\nsubgraph cluster_0 {\ncolor=white;\nrank=same;\nTable1 [label=<\n<table border=\"1\" cellborder=\"0\" cellspacing=\"0\">\n<tr><td bgcolor=\"lightblue\"><b>Professor</b></td></tr>\n<tr><td PORT=\"row11\">Hobbs</td></tr>\n<tr><td PORT=\"row12\">Doe</td></tr>\n</table>\n>];\n}\n \n\n\n\nsubgraph cluster_1 {\ncolor=white;\nrank=same;\nTable2 [label=<\n<table border=\"1\" cellborder=\"0\" cellspacing=\"0\">\n<tr><td bgcolor=\"lightblue\"><b>Class</b></td></tr>\n<tr><td PORT=\"row21\">690-02</td></tr>\n<tr><td PORT=\"row22\">692-01</td></tr>\n<tr><td PORT=\"row23\">405-01</td></tr>\n</table>\n>];\n}\n\nTable1:row11:e -> Table2:row21:w;\nTable1:row12:e -> Table2:row22:w;\nTable1:row11:e -> Table2:row22:w;\n}\n```\n\n\n### Many to Many (M:N)\n\nIn a many-to-many relationship, a single row in the first table can be associated with many rows in the second table, and similarly, a row in the second table can be associated with many rows in the first table. For example, multiple Students can be enrolled in multiple Classes:\n\n\n```{dot}\ndigraph G {\nrankdir = \"LR\";\nnode [shape=plaintext];\nsplines=polyline;\nedge [minlen=1.5];\n\nsubgraph cluster_0 {\ncolor=white;\nrank=same;\nTable1 [label=<\n<table border=\"1\" cellborder=\"0\" cellspacing=\"0\">\n<tr><td bgcolor=\"lightblue\"><b>Student</b></td></tr>\n<tr><td PORT=\"row11\">John</td></tr>\n<tr><td PORT=\"row12\">David</td></tr>\n<tr><td PORT=\"row13\">Celeste</td></tr>\n</table>\n>];\n}\n\n\nsubgraph cluster_1 {\ncolor=white;\nrank=same;\nTable2 [label=<\n<table border=\"1\" cellborder=\"0\" cellspacing=\"0\">\n<tr><td bgcolor=\"lightblue\"><b>Class</b></td></tr>\n<tr><td PORT=\"row21\">690-02</td></tr>\n<tr><td PORT=\"row22\">692-01</td></tr>\n<tr><td PORT=\"row23\">405-01</td></tr>\n</table>\n>];\n}\n\n\nTable1:row11:e -> Table2:row21:w [color=red];\nTable1:row11:e -> Table2:row22:w [color=red];\n\nTable1:row12:e -> Table2:row21:w [color=blue];\nTable1:row12:e -> Table2:row22:w [color=blue];\nTable1:row12:e -> Table2:row23:w [color=blue];\n\nTable1:row13:e -> Table2:row22:w [color=orange];\nTable1:row13:e -> Table2:row23:w [color=orange];\n\n\n}\n```\n\n\n## The Concept of Keys\n\nA Primary Key (PK) is a unique identifier for each row within a table; every table should possess a primary key. To establish relationships between tables, we integrate PKs from one table into another, where they become Foreign Keys (FKs). These FKs allow us to draw connections between related entities across different tables.\n\n::: {#tbl-keys layout-ncol=\"2\"}\n| ClassID (PK) | ProfessorID (FK) | Credits | Location |\n|--------------|------------------|---------|----------|\n| 620-01       | 1                | 4       | LM-340   |\n| 623-01       | 2                | 2       | UM-102   |\n| 663-01       | 2                | 2       | LO-234   |\n\n| ProfessorID (PK) | Professor  |\n|------------------|------------|\n| 1                | Arman      |\n| 2                | Alessandra |\n\nKeys\n:::\n\n## Types of Joins\n\n\n\n\n\nIn relational databases, a join operation is employed to merge two or more tables based on a related column between them. There are several types of joins. To exemplify how joins operate, we will use two tables: `employees` and `projects`. The `employees` table includes `employee_id` (Primary Key) and `name`, while the `projects` table contains `project_id` (Primary Key) and `employee_id` (Foreign Key).\n\n\n::: {.cell layout-ncol=\"2\"}\n\n```{.r .cell-code}\nknitr::kable(employees, caption = \"Employees Table\")\n```\n\n::: {.cell-output-display}\nTable: Employees Table\n\n| employee_id|name  |\n|-----------:|:-----|\n|           1|John  |\n|           2|Jane  |\n|           3|Bob   |\n|           4|Alice |\n|           5|Tom   |\n:::\n\n```{.r .cell-code}\nknitr::kable(projects, caption = \"Projects Table\")\n```\n\n::: {.cell-output-display}\nTable: Projects Table\n\n| project_id| employee_id|\n|----------:|-----------:|\n|          1|           1|\n|          2|           2|\n|          3|           3|\n|          4|           1|\n|          5|           4|\n|          6|           6|\n:::\n:::\n\n\n### Outer Joins\n\nOuter joins are utilized to return matched data and unmatched data from one or both tables, effectively creating a more comprehensive table.\n\n#### Left Join\n\nA left join retrieves all the rows from the left table and only the matched rows from the right table. Essentially, it enriches the left table with additional information.\n\n![Left Join Illustration](images/Left_Join.png)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nleft_join_result <- employees %>%\n  left_join(projects, by = \"employee_id\")\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\nTable: Result of Left Join\n\n| employee_id|name  | project_id|\n|-----------:|:-----|----------:|\n|           1|John  |          1|\n|           1|John  |          4|\n|           2|Jane  |          2|\n|           3|Bob   |          3|\n|           4|Alice |          5|\n|           5|Tom   |         NA|\n:::\n:::\n\n\n#### Right Join\n\nA right join operates similarly to a left join, but it retrieves all the rows from the right table and only the matched rows from the left table.\n\n![Right Join Illustration](images/Right_Join.png)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nright_join_result <- employees %>%\n  right_join(projects, by = \"employee_id\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# echo: false\nknitr::kable(right_join_result, caption = \"Result of Right Join\")\n```\n\n::: {.cell-output-display}\nTable: Result of Right Join\n\n| employee_id|name  | project_id|\n|-----------:|:-----|----------:|\n|           1|John  |          1|\n|           1|John  |          4|\n|           2|Jane  |          2|\n|           3|Bob   |          3|\n|           4|Alice |          5|\n|           6|NA    |          6|\n:::\n:::\n\n\n#### Full Join\n\nA full join returns all the rows from both tables, filling non-matching rows with null values. It essentially merges both tables.\n\n![Full Join Illustration](images/Full_Join.png)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfull_join_result <- employees %>%\n  full_join(projects, by = \"employee_id\")\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\nTable: Result of Full Join\n\n| employee_id|name  | project_id|\n|-----------:|:-----|----------:|\n|           1|John  |          1|\n|           1|John  |          4|\n|           2|Jane  |          2|\n|           3|Bob   |          3|\n|           4|Alice |          5|\n|           5|Tom   |         NA|\n|           6|NA    |          6|\n:::\n:::\n\n\n#### Inner Join\n\nAn inner join only returns the matched rows between two tables. Thus, only the rows that found a match in both tables will be retained.\n\n![Inner Join Illustration](images/Inner_Join.png)\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninner_join_result <- employees %>%\n  inner_join(projects, by = \"employee_id\")\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\nTable: Result of Inner Join\n\n| employee_id|name  | project_id|\n|-----------:|:-----|----------:|\n|           1|John  |          1|\n|           1|John  |          4|\n|           2|Jane  |          2|\n|           3|Bob   |          3|\n|           4|Alice |          5|\n:::\n:::\n\n\n### Filtering Joins\n\n#### Anti Join\n\nAn anti join returns the rows from the left table that do not find a corresponding match in the right table, without adding any new columns to the output. It's useful when you want to filter rows based on the absence of matching entries in the other table.\n\n::: {.cell}\n\n```{.r .cell-code}\nanti_join_result <- employees %>%\n  anti_join(projects, by = \"employee_id\")\n# knitr::kable(anti_join_result, caption = \"Result of Anti Join\")\n```\n:::\n\n\n::: columns\n::: column\n\n::: {.cell}\n::: {.cell-output-display}\nTable: Result of Anti Join\n\n| employee_id|name |\n|-----------:|:----|\n|           5|Tom  |\n:::\n:::\n\n:::\n\n::: column\nTom does not have a project assigned! Perhaps he could take on project 6?\n:::\n:::\n\n#### Semi Join\n\nA semi join is akin to an inner join in identifying matching rows between two tables. However, unlike an inner join, it does not add any new columns to the output. Instead, it filters the rows from the left table that have a corresponding match in the right table. You'd use a semi join when you want to filter the left table based on the presence of matching entries in the right table.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsemi_join_result <- employees %>%\n  semi_join(projects, by = \"employee_id\")\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\nTable: Result of Semi Join\n\n| employee_id|name  |\n|-----------:|:-----|\n|           1|John  |\n|           2|Jane  |\n|           3|Bob   |\n|           4|Alice |\n:::\n:::\n\n\n## Visualizing Databases\n\nWe're going to Unified Modeling Language (UML) to visualize relationships in databases. This might be your first time hearing that there is a language behind diagrams. UML is a standard graphical notation to describe software designs. It is a powerful tools for planning, visualizing and documents your projects. There are different types of diagrams to depict structures, behaviors and interactions with the standard set of symbols and notation.\n\nUML coding tools like Mermaid and Graphviz are great options, but I find that drag-and-drop web applications such as [LucidChart](https://www.lucidchart.com) and [Draw.io](https://app.diagrams.net/) are more user-friendly. First, let's introduce an entity, which is an object (place, person, thing) that we want to track in our database. In our case, these will be a customer, order, and product. Each entity possesses attributes, for example, a customer has `customer_id`, `name`, `email`, `address`, etc., and other entities also have a list of attributes. These entities and attributes are represented as rows and columns, respectively, in your tables. Tables can be interconnected, and these relationships are visualized by drawing a line between the tables. Cardinality is used to describe these relationships in numeric terms, akin to our discussion in @sec-relationships.\n\n![Cardinality](images/cardinality.png)\n\nFor instance, let's examine the relationship between a customer and an order. We ask: what is the relationship between a customer and an order? Using the min, max framework, what is the minimum and maximum number of orders a customer can have? A customer can have zero orders (min = 0) and an indefinite amount of orders (max = many). So, the relationship from customer to order is 0 or many. Now, let's look in the opposite direction: how many customers can an order have? An order can have only one customer (min = 1, max = 1).\n\n![Customer-Order Relationship](images/customer_order.png)\n\nNext, let's examine the relationship between an order and a product. An order can include one or many products, and each product can be in zero or many orders. The complete diagram would resemble the following:\n\n![Entity-Relationship Diagram](images/ERD.png)\n\nCreating such a diagram is recommended whenever you're planning a project with a complex design. It clarifies the necessary tables and their relationships. You could also sketch a diagram whenever you're unsure about a data set. If you'd like to delve deeper into this topic, check out the [Lucid Software YouTube](https://www.youtube.com/@lucid_software) guides and [Neso Academy's Database Management Systems course](https://www.youtube.com/watch?v=6Iu45VZGQDke).\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}